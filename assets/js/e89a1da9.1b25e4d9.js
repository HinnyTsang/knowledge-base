"use strict";(self.webpackChunkknowledge_base=self.webpackChunkknowledge_base||[]).push([[1575],{6239:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>l,metadata:()=>t,toc:()=>a});var t=s(8906),i=s(4848),r=s(8453);const l={slug:"rusty",title:"Notes on Rust",authors:["hinnytsang"],tags:["rust","computer-science"]},o=void 0,c={authorsImageUrls:[void 0]},a=[{value:"Lifetimes",id:"lifetimes",level:2},{value:"Tests",id:"tests",level:2},{value:"Closure",id:"closure",level:2}];function d(e){const n={code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"Some notes for the rust programming language."}),"\n",(0,i.jsx)(n.h2,{id:"lifetimes",children:"Lifetimes"}),"\n",(0,i.jsx)(n.p,{children:"The three rules"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Compiler assigns a lifetime parameter to each parameter that is a reference."}),"\n",(0,i.jsx)(n.li,{children:"If there is exactly one input lifetime parameter, that lifetime is assigned to all output lifetime parameters."}),"\n",(0,i.jsxs)(n.li,{children:["If ",(0,i.jsx)(n.code,{children:"&self"})," or ",(0,i.jsx)(n.code,{children:"&mut self"})," is one of the input lifetime parameters, the lifetime of ",(0,i.jsx)(n.code,{children:"self"})," is assigned to all output lifetime parameters."]}),"\n"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"'static"}),": Static Lifetime denotes that the reference can live for the entire duration of the program."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"tests",children:"Tests"}),"\n",(0,i.jsx)(n.p,{children:"Should know:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"#[cfg(test)]"}),": module only compiled when running tests"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"#[test]"}),": function is a test function"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"cargo test"}),": run tests","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"cargo test -- --test-threads=1"})," to run tests in single thread"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"cargo test <test_name>"})," to run specific test"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"cargo test -- --show-output"})," to show output of passing tests"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"cargo test -- --ignored"})," to run ignored tests"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"assert!"}),", ",(0,i.jsx)(n.code,{children:"assert_eq!"}),", ",(0,i.jsx)(n.code,{children:"assert_ne!"}),": macros to check if conditions are met"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"#[should_panic]"}),": test should panic to pass, e.g.","\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'#[test]\n#[should_panic] // Or #[should_panic(expected = "divide by zero")] to check panic message\nfn test_divide_by_zero() {\n    let _ = 1 / 0;\n}\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Result<T, E>"}),": test can return a Result type instead of using assert macros, but can't use with ",(0,i.jsx)(n.code,{children:"#[should_panic]"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ignore"})," attribute to ignore specific tests, use after ",(0,i.jsx)(n.code,{children:"#[test]"})]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"closure",children:"Closure"}),"\n",(0,i.jsx)(n.p,{children:"Closure will automically implment 1, 2, or all of the following traits:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Fn"}),": closure only borrows values from the environment immutably"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"FnMut"}),": closure borrows values from the environment mutably"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"FnOnce"}),": closure takes ownership of values from the environment (",(0,i.jsx)(n.code,{children:"move"})," keyword)"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>o});var t=s(6540);const i={},r=t.createContext(i);function l(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),t.createElement(r.Provider,{value:n},e.children)}},8906:e=>{e.exports=JSON.parse('{"permalink":"/knowledge-base/rusty","source":"@site/blog/2025-10-14-rusty.md","title":"Notes on Rust","description":"Some notes for the rust programming language.","date":"2025-10-14T00:00:00.000Z","tags":[{"inline":true,"label":"rust","permalink":"/knowledge-base/tags/rust"},{"inline":false,"label":"Computer Science","permalink":"/knowledge-base/tags/computer-science","description":"Computer Science Concepts and Techniques"}],"readingTime":1.34,"hasTruncateMarker":true,"authors":[{"name":"Hinny Tsang","title":"Data Scientist @ Pollock Asset Management","url":"https://github.com/HinnyTsang","page":{"permalink":"/knowledge-base/authors/hinnytsang"},"socials":{"linkedin":"https://www.linkedin.com/in/HinnyTsang/","github":"https://github.com/HinnyTsang"},"imageURL":"https://github.com/HinnyTsang.png","key":"hinnytsang"}],"frontMatter":{"slug":"rusty","title":"Notes on Rust","authors":["hinnytsang"],"tags":["rust","computer-science"]},"unlisted":false,"nextItem":{"title":"Operating Systems","permalink":"/knowledge-base/operating-systems"}}')}}]);