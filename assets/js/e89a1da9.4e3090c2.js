"use strict";(self.webpackChunkknowledge_base=self.webpackChunkknowledge_base||[]).push([[1575],{169:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>d});var r=s(8906),i=s(4848),t=s(8453);const l={slug:"rusty",title:"Notes on Rust",authors:["hinnytsang"],tags:["rust","computer-science"]},c=void 0,o={authorsImageUrls:[void 0]},d=[{value:"Borrow Checker",id:"borrow-checker",level:2},{value:"Lifetimes",id:"lifetimes",level:2},{value:"Tests",id:"tests",level:2},{value:"Closure",id:"closure",level:2},{value:"Smart Pointers",id:"smart-pointers",level:2},{value:"Interior Mutability",id:"interior-mutability",level:2},{value:"Concurrency",id:"concurrency",level:2},{value:"Send and Sync Traits",id:"send-and-sync-traits",level:3},{value:"Async tasks",id:"async-tasks",level:3},{value:"Pin for futures",id:"pin-for-futures",level:2}];function a(e){const n={code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"Some notes for the rust programming language."}),"\n",(0,i.jsx)(n.h2,{id:"borrow-checker",children:"Borrow Checker"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Ownership rules:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Each value has one owner."}),"\n",(0,i.jsx)(n.li,{children:"There can only be one owner at a time."}),"\n",(0,i.jsx)(n.li,{children:"References will be dropped when go out of scope."}),"\n",(0,i.jsx)(n.li,{children:"The checker evaluates at compile time."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"References and Borrowing:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"At any given time, you can have either"}),"\n",(0,i.jsxs)(n.li,{children:["1 ",(0,i.jsx)(n.em,{children:"mutable"})," reference, or"]}),"\n",(0,i.jsxs)(n.li,{children:["any number of ",(0,i.jsx)(n.em,{children:"immutable"})," references."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"lifetimes",children:"Lifetimes"}),"\n",(0,i.jsx)(n.p,{children:"The three rules"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Compiler assigns a lifetime parameter to each parameter that is a reference."}),"\n",(0,i.jsx)(n.li,{children:"If there is exactly one input lifetime parameter, that lifetime is assigned to all output lifetime parameters."}),"\n",(0,i.jsxs)(n.li,{children:["If ",(0,i.jsx)(n.code,{children:"&self"})," or ",(0,i.jsx)(n.code,{children:"&mut self"})," is one of the input lifetime parameters, the lifetime of ",(0,i.jsx)(n.code,{children:"self"})," is assigned to all output lifetime parameters."]}),"\n"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"'static"}),": Static Lifetime denotes that the reference can live for the entire duration of the program."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"tests",children:"Tests"}),"\n",(0,i.jsx)(n.p,{children:"Should know:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"#[cfg(test)]"}),": module only compiled when running tests"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"#[test]"}),": function is a test function"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"cargo test"}),": run testsj","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"cargo test -- --test-threads=1"})," to run tests in single thread"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"cargo test <test_name>"})," to run specific test"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"cargo test -- --show-output"})," to show output of passing tests"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"cargo test -- --ignored"})," to run ignored tests"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"assert!"}),", ",(0,i.jsx)(n.code,{children:"assert_eq!"}),", ",(0,i.jsx)(n.code,{children:"assert_ne!"}),": macros to check if conditions are met"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"#[should_panic]"}),": test should panic to pass, e.g.","\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'#[test]\n#[should_panic] // Or #[should_panic(expected = "divide by zero")] to check panic message\nfn test_divide_by_zero() {\n    let _ = 1 / 0;\n}\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Result<T, E>"}),": test can return a Result type instead of using assert macros, but can't use with ",(0,i.jsx)(n.code,{children:"#[should_panic]"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ignore"})," attribute to ignore specific tests, use after ",(0,i.jsx)(n.code,{children:"#[test]"})]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"closure",children:"Closure"}),"\n",(0,i.jsx)(n.p,{children:"Closure will automically implment 1, 2, or all of the following traits:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Fn"}),": closure only borrows values from the environment immutably"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"FnMut"}),": closure borrows values from the environment mutably"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"FnOnce"}),": closure takes ownership of values from the environment (",(0,i.jsx)(n.code,{children:"move"})," keyword)"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"smart-pointers",children:"Smart Pointers"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Box<T>"}),": for heap allocation, single ownership."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Rc<T>"}),": for shared ownership, reference counting, single-threaded."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"RefCell<T>"}),": allows mutable borrows checked at runtime, even if ",(0,i.jsx)(n.code,{children:"RefCell<T>"})," is immutable, single-threaded.","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Rc<RefCell<T>>"}),": shared ownership with interior mutability, single-threaded!"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Weak<T>"}),": non-owning reference to ",(0,i.jsx)(n.code,{children:"Rc<T>"}),", prevents reference cycles, created using ",(0,i.jsx)(n.code,{children:"Rc::downgrade(&rc)"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"interior-mutability",children:"Interior Mutability"}),"\n",(0,i.jsx)(n.p,{children:"Rust enforces borrowing rules at compile time. While it may reject safe code that violates these rules, interior mutability is a way to check these rules at runtime."}),"\n",(0,i.jsx)(n.h2,{id:"concurrency",children:"Concurrency"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Arc<T>"}),": Atomic Reference Counted, thread-safe version of ",(0,i.jsx)(n.code,{children:"Rc<T>"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Mutex<T>"}),": Mutual Exclusion, provides interior mutability with locking mechanism for thread safety."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"RwLock<T>"}),": Read-Write Lock, allows multiple readers or one writer at a time, useful for read-heavy scenarios."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Threads can be spawned using ",(0,i.jsx)(n.code,{children:"std::thread::spawn"})," and can be joined using the ",(0,i.jsx)(n.code,{children:"join"})," method on the thread handle."]}),"\n",(0,i.jsx)(n.h3,{id:"send-and-sync-traits",children:"Send and Sync Traits"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Send"}),": Transfer ownership to another thread."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Sync"}),": Allow references to be shared between multiple threads."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"async-tasks",children:"Async tasks"}),"\n",(0,i.jsxs)(n.p,{children:["The rust book introduced ",(0,i.jsx)(n.code,{children:"trpl"})," library for async programming, below are some common uses:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"trpl::spawn_task(future)"}),": spawn a new async task."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"trpl::join(futures, future2)"}),": wait for two futures to complete."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"trpl::join!(...futures)"}),": wait for multiple futures to complete."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"trpl::race(future1, futures2)"}),": wait for the first future to complete."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"trpl::channel"}),": create a channel for communication between tasks (mpsc, async)."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Streams:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"trpl::stream_from_iter(iter)"}),": create a stream from an iterator."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"trpl::ReceiverStream(rx)"}),": create a stream from a receiver."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Create futures"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"let my_future = async {\n    // async code here\n};\n\nlet my_future_with_move = async move {\n    // async code here\n};\n\nmy_future.await;\n"})}),"\n",(0,i.jsx)(n.h2,{id:"pin-for-futures",children:"Pin for futures"}),"\n",(0,i.jsx)(n.p,{children:"Unlike other types, futures may be self-referential, meaning they can contain references to themselves. This can lead to issues when the future is moved in memory, as the references may become invalid."}),"\n",(0,i.jsxs)(n.p,{children:["To address this, Rust provides the ",(0,i.jsx)(n.code,{children:"Pin"})," type, which prevents a value from being moved once it has been pinned. This is particularly useful for futures, as it ensures that the self-referential parts of the future remain valid for the duration of its execution."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Unpin"})," and ",(0,i.jsx)(n.code,{children:"!Unpin"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["By default, most types in Rust implement the ",(0,i.jsx)(n.code,{children:"Unpin"})," trait, which means they can be safely moved in memory. However, some types, such as certain futures or self-referential structs, do not implement ",(0,i.jsx)(n.code,{children:"Unpin"})," and are considered ",(0,i.jsx)(n.code,{children:"!Unpin"}),". These types must be pinned to ensure their memory location remains stable."]}),"\n",(0,i.jsxs)(n.p,{children:["When working with futures that are ",(0,i.jsx)(n.code,{children:"!Unpin"}),", you typically use ",(0,i.jsx)(n.code,{children:"Pin<Box<dyn Future<Output = T>>>"})," or ",(0,i.jsx)(n.code,{children:"Pin<&mut dyn Future<Output = T>>"})," to pin them in place. This ensures that the future can be safely polled without the risk of invalidating any self-references."]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>c});var r=s(6540);const i={},t=r.createContext(i);function l(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),r.createElement(t.Provider,{value:n},e.children)}},8906:e=>{e.exports=JSON.parse('{"permalink":"/knowledge-base/rusty","source":"@site/blog/2025-10-14-rusty.md","title":"Notes on Rust","description":"Some notes for the rust programming language.","date":"2025-10-14T00:00:00.000Z","tags":[{"inline":false,"label":"Rust","permalink":"/knowledge-base/tags/rust","description":"Rust Programming Language"},{"inline":false,"label":"Computer Science","permalink":"/knowledge-base/tags/computer-science","description":"Computer Science Concepts and Techniques"}],"readingTime":3.77,"hasTruncateMarker":true,"authors":[{"name":"Hinny Tsang","title":"Data Scientist @ Pollock Asset Management","url":"https://github.com/HinnyTsang","page":{"permalink":"/knowledge-base/authors/hinnytsang"},"socials":{"linkedin":"https://www.linkedin.com/in/HinnyTsang/","github":"https://github.com/HinnyTsang"},"imageURL":"https://github.com/HinnyTsang.png","key":"hinnytsang"}],"frontMatter":{"slug":"rusty","title":"Notes on Rust","authors":["hinnytsang"],"tags":["rust","computer-science"]},"unlisted":false,"prevItem":{"title":"Return and Volatility","permalink":"/knowledge-base/wqu-return-and-volatility"},"nextItem":{"title":"Operating Systems","permalink":"/knowledge-base/operating-systems"}}')}}]);