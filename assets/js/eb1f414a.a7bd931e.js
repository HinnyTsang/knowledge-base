"use strict";(self.webpackChunkknowledge_base=self.webpackChunkknowledge_base||[]).push([[6763],{6488:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>t,contentTitle:()=>c,default:()=>h,frontMatter:()=>d,metadata:()=>i,toc:()=>a});var i=s(7006),l=s(4848),r=s(8453);const d={slug:"operating-systems",title:"Operating Systems",authors:["hinnytsang"],tags:["cpp","computer-science"]},c="Representing and Manipulating Information",t={authorsImageUrls:[void 0]},a=[{value:"X86-64 Registers",id:"x86-64-registers",level:2},{value:"Common Instructions",id:"common-instructions",level:2},{value:"Address computation",id:"address-computation",level:2},{value:"Processor states",id:"processor-states",level:2},{value:"Conditional Move Instructions",id:"conditional-move-instructions",level:2},{value:"Switch",id:"switch",level:2},{value:"x86-64 Stack",id:"x86-64-stack",level:2},{value:"Control Flow",id:"control-flow",level:2},{value:"Register Saving Convention",id:"register-saving-convention",level:2},{value:"x86-64 Linux Memory Layout",id:"x86-64-linux-memory-layout",level:2},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Summary",id:"summary",level:2},{value:"Memory Mapping",id:"memory-mapping",level:2},{value:"Dynamic Memory Allocation",id:"dynamic-memory-allocation",level:2}];function o(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.p,{children:"Notes on CMU 213/513 Introduction to Computer Systems."}),"\n",(0,l.jsxs)(n.p,{children:["Course link: ",(0,l.jsx)(n.a,{href:"https://www.cs.cmu.edu/~213/",children:"https://www.cs.cmu.edu/~213/"}),"."]}),"\n",(0,l.jsx)(n.h2,{id:"x86-64-registers",children:"X86-64 Registers"}),"\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"Register"}),(0,l.jsx)(n.th,{children:"Description"}),(0,l.jsx)(n.th,{children:"32-bit Equivalent"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"%rax"}),(0,l.jsx)(n.td,{children:"Accumulator for operands and results data"}),(0,l.jsx)(n.td,{children:"%eax"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"%rbx"}),(0,l.jsx)(n.td,{children:"Pointer to data in the data segment"}),(0,l.jsx)(n.td,{children:"%ebx"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"%rcx"}),(0,l.jsx)(n.td,{children:"Counter for string and loop operations"}),(0,l.jsx)(n.td,{children:"%ecx"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"%rdx"}),(0,l.jsx)(n.td,{children:"I/O pointer"}),(0,l.jsx)(n.td,{children:"%edx"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"%rdi"}),(0,l.jsx)(n.td,{children:"Pointer to first data in the segment (memory)"}),(0,l.jsx)(n.td,{children:"%edi"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"%rsi"}),(0,l.jsx)(n.td,{children:"Pointer to last data in the segment (memory)"}),(0,l.jsx)(n.td,{children:"%esi"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"%rbp"}),(0,l.jsxs)(n.td,{children:["Pointer to the base of the ",(0,l.jsx)(n.em,{children:"stack"})]}),(0,l.jsx)(n.td,{children:"%ebp"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"%rsp"}),(0,l.jsxs)(n.td,{children:["Pointer to the top of the ",(0,l.jsx)(n.em,{children:"stack"})]}),(0,l.jsx)(n.td,{children:"%esp"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"%r8-%r15"}),(0,l.jsx)(n.td,{children:"Additional general-purpose registers"}),(0,l.jsx)(n.td,{children:"%r8d-%r15d"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"%rip"}),(0,l.jsx)(n.td,{children:"Instruction pointer (Programm counter)"}),(0,l.jsx)(n.td,{children:"%eip"})]})]})]}),"\n",(0,l.jsx)(n.h2,{id:"common-instructions",children:"Common Instructions"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Move Data"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"mov dest, src"}),": Move data from ",(0,l.jsx)(n.code,{children:"src"})," to ",(0,l.jsx)(n.code,{children:"dest"}),"."]}),"\n",(0,l.jsxs)(n.li,{children:["Operand Types","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["Immediate: Constant value (e.g., ",(0,l.jsx)(n.code,{children:"$5"}),", ",(0,l.jsx)(n.code,{children:"$0xFF"}),"), start with ",(0,l.jsx)(n.code,{children:"$"}),"."]}),"\n",(0,l.jsxs)(n.li,{children:["Register: Value stored in a register (e.g., ",(0,l.jsx)(n.code,{children:"%rax"}),", ",(0,l.jsx)(n.code,{children:"%r13"}),")."]}),"\n",(0,l.jsxs)(n.li,{children:["Memory: Value stored in memory (e.g., ",(0,l.jsx)(n.code,{children:"[RAX]"}),", ",(0,l.jsx)(n.code,{children:"[RSP+8]"}),")."]}),"\n",(0,l.jsx)(n.li,{children:"Rules 1: No way to move directly from memory to memory."}),"\n",(0,l.jsx)(n.li,{children:"Rules 2: No way to move anything to immediate."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"mov (%rcx),%rax"})," ; Move the 8 bytes at address in rcx to rax"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"mov $0x12345678,%rax"})," ; Move the immediate value 0x12345678 to rax"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"mov %rax,%rbx"})," ; Move the value in rax to rbx"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"mov %rax,(%rcx)"})," ; Move the value in rax to the address in rcx"]}),"\n"]}),"\n",(0,l.jsxs)(n.ol,{start:"2",children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"leaq"}),": Load effective address"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"leaq dest, src"}),": Load the address of ",(0,l.jsx)(n.code,{children:"src"})," into ",(0,l.jsx)(n.code,{children:"dest"}),"."]}),"\n",(0,l.jsxs)(n.li,{children:["Example: ",(0,l.jsx)(n.code,{children:"leaq 8(%rcx), %rax"})," ; Load the address (rcx + 8) into rax"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Arithmetic and Logic Instructions"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"add, sub, imul, xor, and, or"})," etc."]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:["Example: ",(0,l.jsx)(n.code,{children:"add %rbx, %rax"})," ; rax = rax + rbx"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Shift and logical shift:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"sal"})," or ",(0,l.jsx)(n.code,{children:"shl"}),": Shift left (multiply by 2)"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"sar"}),": Shift right (divide by 2, signed, arithmetic)"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"shr"}),": Logical shift right (divide by 2, unsigned)"]}),"\n",(0,l.jsxs)(n.li,{children:["Example: ",(0,l.jsx)(n.code,{children:"shl $3, %rax"})," ; rax = rax * 8"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.ol,{start:"4",children:["\n",(0,l.jsx)(n.li,{children:"Jumping"}),"\n"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"jmp label"}),": Unconditional jump to ",(0,l.jsx)(n.code,{children:"label"}),"."]}),"\n",(0,l.jsxs)(n.li,{children:["Conditional jumps based on flags:","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"je"})," (jump if equal, ZF=1)"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"jne"})," (jump if not equal, ZF=0)"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"js"})," (jump if sign, SF=1)"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"jns"})," (jump if not sign, SF=0)"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"jl"})," (jump if less, SF != OF)"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"jle"})," (jump if less or equal, ZF=1 or SF != OF)"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"jg"})," (jump if greater, ZF=0 and SF == OF)"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"jge"})," (jump if greater or equal, SF == OF)"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["Example: ",(0,l.jsx)(n.code,{children:"je label"})," ; Jump to label if the zero flag is set"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"address-computation",children:"Address computation"}),"\n",(0,l.jsx)(n.p,{children:"Let say %rdx = 0xf000 and %rcx = 0x0100"}),"\n",(0,l.jsx)(n.p,{children:"Expressions:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"0x8(%rdx)"}),": Address = 0xf000 + 0x8 = 0xf008"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"(%rdx,%rcx)"}),": Address = 0xf000 + 0x0100 = 0xf100"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"(%rdx,%rcx,4)"}),": Address = 0xf000 + 0x0100 * 4 = 0xf400"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"0x10(,%rdx, 2)"}),": Address = 0x10 + 0xf000 * 2 = 0x1e010"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"0x20(%rdx,%rcx,8)"}),": Address = 0x20 + 0xf000 + 0x0100 * 8 = 0xf820"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"processor-states",children:"Processor states"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Temporary values (%rax, %rbx, etc.)"}),"\n",(0,l.jsx)(n.li,{children:"Location of runtime stack (i.e., %rsp)"}),"\n",(0,l.jsx)(n.li,{children:"Location of current code (i.e., %rip)"}),"\n",(0,l.jsxs)(n.li,{children:["Stateus of recent tests (CF, ZF, SF, OF, etc.)","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Carry Flag (CF): Set if an operation generates a carry."}),"\n",(0,l.jsx)(n.li,{children:"Zero Flag (ZF): Set if the result of an operation is zero."}),"\n",(0,l.jsx)(n.li,{children:"Sign Flag (SF): Set if the result of an operation is negative."}),"\n",(0,l.jsx)(n.li,{children:"Overflow Flag (OF): Set if an operation results in a signed overflow."}),"\n",(0,l.jsxs)(n.li,{children:["Implicitly set by arithmetic and logical instructions. (e.g., ",(0,l.jsx)(n.code,{children:"add"}),", ",(0,l.jsx)(n.code,{children:"sub"}),", ",(0,l.jsx)(n.code,{children:"cmp"}),")"]}),"\n",(0,l.jsxs)(n.li,{children:["Not affected by data movement instructions (e.g., ",(0,l.jsx)(n.code,{children:"mov"}),", ",(0,l.jsx)(n.code,{children:"lea"}),")."]}),"\n",(0,l.jsxs)(n.li,{children:["Explicity set by ",(0,l.jsx)(n.code,{children:"cmp"})," instruction.","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["Let say ",(0,l.jsx)(n.code,{children:"cmpq b, a"}),", like ",(0,l.jsx)(n.code,{children:"a-b"})," without setting destination","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"CF is set if a < b, ZF is set if a == b, SF is set if a < b (signed), OF is set if overflow occurs (signed)."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"conditional-move-instructions",children:"Conditional Move Instructions"}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"cmoveX dest, src"}),": Move ",(0,l.jsx)(n.code,{children:"src"})," to ",(0,l.jsx)(n.code,{children:"dest"})," if condition X is met."]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"X can be:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"e"}),": equal (ZF=1)"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"ne"}),": not equal (ZF=0)"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"l"}),": less (SF != OF)"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"le"}),": less or equal (ZF=1 or SF != OF)"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"g"}),": greater (ZF=0 and SF == OF)"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"ge"}),": greater or equal (SF == OF)"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"s"}),": sign (SF=1)"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"ns"}),": not sign (SF=0)"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Example:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-assembly",children:"absdiff:\n  movq %rdi, %rax      # rax = a\n  subq %rsi, %rax      # rax = a - b\n  movq %rsi, %rdx      # rdx = b\n  subq %rdi, %rdx      # rdx = b - a\n  cmovle %rdx, %rax    # if b - a > 0, rax = a\n  ret\n"})}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Branching can be expensive due to pipeline stalls."}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Conditional move instructions can help avoid branches."}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"40 cycles for a mispredicted branch vs. 1 cycle for a conditional move."}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Bad cases:"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:["Expensive calculation, e.g., ",(0,l.jsx)(n.code,{children:"val = t()? hard1(): hard2();"}),"."]}),"\n",(0,l.jsxs)(n.li,{children:["Risky computations, e.g., ",(0,l.jsx)(n.code,{children:"val = p? *p: 0;"}),", as both values are computed."]}),"\n",(0,l.jsxs)(n.li,{children:["With side effects, e.g., ",(0,l.jsx)(n.code,{children:"val = (p > 0) ? p *= 7 : p += 3;"}),", as both values are computed and ",(0,l.jsx)(n.code,{children:"p"})," is incremented."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"switch",children:"Switch"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Implemented with a jump table for dense cases."}),"\n",(0,l.jsx)(n.p,{children:"let say"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-cpp",children:"\nswitch(x) {\n  case val_0:\n    block_0;\n  ...etc\n}\n"})}),"\n",(0,l.jsx)(n.p,{children:"The assembly code:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-assembly",children:"cmpl $val_n, %eax\nja   default_case           # if x > val_n, jump to default_case (jump above)\njmp  *.L4(,%rax,8)  # jump to the address in jump_table + x * 8\n\n# jump_table:\n.section .rodata\n  .align 8\n.L4:\n  .quad case_0\n  .quad case_1\n  ...\n  .quad case_n\n"})}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Jump table is an array of addresses of the case blocks!!"}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.h1,{id:"procedures",children:"Procedures"}),"\n",(0,l.jsx)(n.p,{children:"Mechanisms:"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsx)(n.li,{children:"Passing control."}),"\n",(0,l.jsx)(n.li,{children:"Passing Data."}),"\n",(0,l.jsx)(n.li,{children:"Memory management."}),"\n",(0,l.jsx)(n.li,{children:"Mechanism all implemented with machine instructions."}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"x86-64 implementation of a procedure uses only those mechanisms required."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"x86-64-stack",children:"x86-64 Stack"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Region of memory managed with stack discipline (LIFO)."}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Grows toward lower addresses."}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Register %rsp points to the top of the stack."}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"pushq src"}),": Decrement %rsp by 8, then store ",(0,l.jsx)(n.code,{children:"src"})," at the address in %rsp."]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"popq dest"}),": Load the value at the address in %rsp into ",(0,l.jsx)(n.code,{children:"dest"}),", then increment %rsp by 8. (The original value is still in memory but not in the stack!)"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"control-flow",children:"Control Flow"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Call instruction"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"call label"}),": Push the address of the next instruction (return address) onto the stack, then jump to ",(0,l.jsx)(n.code,{children:"label"}),"."]}),"\n",(0,l.jsxs)(n.li,{children:["Example: ",(0,l.jsx)(n.code,{children:"call foo"})," ; Call the procedure ",(0,l.jsx)(n.code,{children:"foo"}),"."]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Return instruction"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"ret"}),": Pop the return address from the stack and jump to that address."]}),"\n",(0,l.jsxs)(n.li,{children:["Example: ",(0,l.jsx)(n.code,{children:"ret"})," ; Return from the current procedure."]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Stack Frame"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Every new function call creates a new stack frame."}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Stack frame contains:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Return address"}),"\n",(0,l.jsx)(n.li,{children:"Base register (%rbp)"}),"\n",(0,l.jsx)(n.li,{children:"Stack register (%rsp)"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Recursive functions create multiple stack frames, probably leading to stack overflow!"}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Caller frame vs. Callee frame (Current stack  frame)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Caller frame: The stack frame of the function that calls another function."}),"\n",(0,l.jsx)(n.li,{children:"Callee frame: The stack frame of the function that is called."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"register-saving-convention",children:"Register Saving Convention"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["Caller-saved registers: %rax, %rcx, %rdx, %rsi, %rdi, %r8-%r11","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Caller must save and restore if it wants to preserve their values across a function call."}),"\n",(0,l.jsxs)(n.li,{children:["Callee-saved registers: %rbx, %rbp, %r12-%r15","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Callee must save and restore if it uses them."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"x86-64-linux-memory-layout",children:"x86-64 Linux Memory Layout"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Stack"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["Runtime stack (8MB limit), check by ",(0,l.jsx)(n.code,{children:"limit"})," command!v"]}),"\n",(0,l.jsx)(n.li,{children:"E.g. local variables"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Heap"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["Dynamically allocated memory (e.g., ",(0,l.jsx)(n.code,{children:"malloc"}),", ",(0,l.jsx)(n.code,{children:"new"}),")"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Data"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Statically allocated data"}),"\n",(0,l.jsxs)(n.li,{children:["E.g. global variables, ",(0,l.jsx)(n.code,{children:"static"})," variables"]}),"\n"]}),"\n",(0,l.jsxs)(n.ol,{start:"4",children:["\n",(0,l.jsx)(n.li,{children:"Text / Shared Library"}),"\n"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Executable machine instructions"}),"\n",(0,l.jsx)(n.li,{children:"Readonly."}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-mermaid",children:"graph TD\n    subgraph Stack\n        direction TB\n        StackTop[High Address]\n        StackBottom[Low Address]\n    end\n    subgraph Heap\n        direction TB\n        HeapTop[High Address]\n        HeapBottom[Low Address]\n    end\n    subgraph Data\n        direction TB\n        DataTop[High Address]\n        DataBottom[Low Address]\n    end\n    subgraph Text\n        direction TB\n        TextTop[High Address]\n        TextBottom[Low Address]\n    end\n\n    StackTop --\x3e StackBottom\n    StackBottom --\x3e HeapTop\n    HeapTop --\x3e HeapBottom\n    HeapBottom --\x3e DataTop\n    DataTop --\x3e DataBottom\n    DataBottom --\x3e TextTop\n    TextTop --\x3e TextBottom\n"})}),"\n",(0,l.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Minimize procedure calls"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Inline small functions."}),"\n",(0,l.jsx)(n.li,{children:"Use macros for very small functions."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Minimize register saving"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Avoid using callee-saved registers in leaf functions."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Shift instead of multiply or divide"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Multiply usually need 3 cycles, shift only 1 cycle."}),"\n",(0,l.jsx)(n.li,{children:"Addition is also 1 cycle."}),"\n"]}),"\n",(0,l.jsxs)(n.ol,{start:"4",children:["\n",(0,l.jsx)(n.li,{children:"AVX2 / SIMD (Vectorization)"}),"\n"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Single Instruction Multiple Data"}),"\n",(0,l.jsx)(n.li,{children:"Process multiple data with a single instruction."}),"\n",(0,l.jsx)(n.li,{children:"E.g., process 8 integers (32-bit) or 4 doubles (64-bit) in parallel."}),"\n"]}),"\n",(0,l.jsxs)(n.ol,{start:"5",children:["\n",(0,l.jsx)(n.li,{children:"Branches"}),"\n"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Avoid branches when possible."}),"\n",(0,l.jsx)(n.li,{children:"Use conditional move instructions to avoid branches."}),"\n",(0,l.jsx)(n.li,{children:"Branch prediction: CPU predicts the outcome of a branch to keep the pipeline full."}),"\n",(0,l.jsx)(n.li,{children:"Branch Misprediction Recover Penalty: 20-40 cycles."}),"\n",(0,l.jsx)(n.li,{children:"Can be a major performance bottleneck."}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,l.jsx)(n.p,{children:"Assembler Control"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Conditional jump"}),"\n",(0,l.jsx)(n.li,{children:"Conditional move"}),"\n",(0,l.jsx)(n.li,{children:"Indirect jump (jump table)"}),"\n"]}),"\n",(0,l.jsx)(n.h1,{id:"memory",children:"Memory"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"MMU (Mmory-management unit), a hardware device that maps virtual addresses to physical addresses."}),"\n",(0,l.jsx)(n.li,{children:"PTE (Page Table Entry), a data structure used by the MMU to store the mapping between virtual and physical addresses. (L1, L2 cache in the MMU)."}),"\n",(0,l.jsx)(n.li,{children:"PTA (Page Table Address), the address of the page table in memory."}),"\n",(0,l.jsx)(n.li,{children:"PPN (Physical Page Number), the number of a physical page."}),"\n",(0,l.jsx)(n.li,{children:"VPN (Virtual Page Number), the number of a virtual page."}),"\n",(0,l.jsx)(n.li,{children:"VPO (Virtual Page Offset), the offset within a virtual page."}),"\n",(0,l.jsx)(n.li,{children:"PPO (Physical Page Offset), the offset within a physical page."}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Simple Memory System example, TLB(Translation Lookaside Buffer):"}),"\n",(0,l.jsx)(n.p,{children:"Addressing"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"16 bits vertual address space"}),"\n",(0,l.jsx)(n.li,{children:"12 bits physical address space"}),"\n",(0,l.jsx)(n.li,{children:"64 kB vertual memory"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"memory-mapping",children:"Memory Mapping"}),"\n",(0,l.jsx)(n.p,{children:"VM areas initialized by associating them with disk objects."}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Virtual Address = VPN * Page Size + VPO"}),"\n",(0,l.jsx)(n.li,{children:"Physical Address = PPN * Page Size + PPO"}),"\n",(0,l.jsx)(n.li,{children:"Page Size = 2^n bytes, n is the number of bits for the page offset"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Sometime different process will access the same physical memory, e.g., shared libraries."}),"\n",(0,l.jsx)(n.p,{children:"Copy-on-write (COW) Objects: Steps"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsx)(n.li,{children:"Create a new VM area for the new process."}),"\n",(0,l.jsx)(n.li,{children:"Map the new VM area to the same disk object as the original process."}),"\n",(0,l.jsx)(n.li,{children:"Mark the new VM area as read-only."}),"\n",(0,l.jsx)(n.li,{children:"When either process tries to write to the shared page, a page fault occurs."}),"\n",(0,l.jsx)(n.li,{children:"The OS allocates a new physical page, copies the contents of the original page to\nthe new page, and updates the page table to map the virtual address to the new physical page."}),"\n",(0,l.jsx)(n.li,{children:"The write operation is then retried, and it succeeds on the new page."}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"dynamic-memory-allocation",children:"Dynamic Memory Allocation"}),"\n",(0,l.jsx)(n.p,{children:"Keep Track of Free Blocks"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsx)(n.li,{children:"Implicit free list"}),"\n"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"link all blocks by length"}),"\n",(0,l.jsxs)(n.li,{children:["for each block, need both size and allocation status.","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Could store this information in two words: wasteful."}),"\n",(0,l.jsx)(n.li,{children:"standard trick, use the low-order bit of the size word to indicate allocation status."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.ol,{start:"2",children:["\n",(0,l.jsx)(n.li,{children:"Explicit free list"}),"\n"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:'Link all "free" blocks'}),"\n"]}),"\n",(0,l.jsxs)(n.ol,{start:"3",children:["\n",(0,l.jsx)(n.li,{children:"Segregated free list"}),"\n"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Different free lists for different size classes"}),"\n"]}),"\n",(0,l.jsxs)(n.ol,{start:"4",children:["\n",(0,l.jsx)(n.li,{children:"Blocks sorted by size"}),"\n"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Used balanced tree (red-black tree)."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(o,{...e})}):o(e)}},7006:e=>{e.exports=JSON.parse('{"permalink":"/knowledge-base/operating-systems","source":"@site/blog/2025-10-01-operating-systems.md","title":"Operating Systems","description":"Notes on CMU 213/513 Introduction to Computer Systems.","date":"2025-10-01T00:00:00.000Z","tags":[{"inline":false,"label":"C++","permalink":"/knowledge-base/tags/cpp","description":"C++ Programming Language"},{"inline":false,"label":"Computer Science","permalink":"/knowledge-base/tags/computer-science","description":"Computer Science Concepts and Techniques"}],"readingTime":9.4,"hasTruncateMarker":true,"authors":[{"name":"Hinny Tsang","title":"Data Scientist @ Pollock Asset Management","url":"https://github.com/HinnyTsang","page":{"permalink":"/knowledge-base/authors/hinnytsang"},"socials":{"linkedin":"https://www.linkedin.com/in/HinnyTsang/","github":"https://github.com/HinnyTsang"},"imageURL":"https://github.com/HinnyTsang.png","key":"hinnytsang"}],"frontMatter":{"slug":"operating-systems","title":"Operating Systems","authors":["hinnytsang"],"tags":["cpp","computer-science"]},"unlisted":false,"nextItem":{"title":"Networkings","permalink":"/knowledge-base/networkings"}}')},8453:(e,n,s)=>{s.d(n,{R:()=>d,x:()=>c});var i=s(6540);const l={},r=i.createContext(l);function d(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:d(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);